/*
 * ISC License
 *
 * Copyright (c) 2019
 * Samuele Andreoli <samuele dot andreoli at studenti dot unitn dot it>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "distributions.h"

/* Distributions configuration */

/* Dsitribution D1 */
#if FRODO_DISTRIBUTION == FRODO_D1
#define FRODO_DISTRIBUTION_BITS 8
#define FRODO_CDF_LENGTH 4
const uint16_t CDF[FRODO_CDF_LENGTH] = {43, 104, 124, 127};
/* Dsitribution D2 */
#elif FRODO_DISTRIBUTION == FRODO_D2
#define FRODO_DISTRIBUTION_BITS 12
#define FRODO_CDF_LENGTH 5
const uint16_t CDF[FRODO_CDF_LENGTH] = {784, 1774, 2022, 2046, 2047};
/* Dsitribution D3 */
#elif FRODO_DISTRIBUTION == FRODO_D3
#define FRODO_DISTRIBUTION_BITS 12
#define FRODO_CDF_LENGTH 6
const uint16_t CDF[FRODO_CDF_LENGTH] = {602, 1521, 1927, 2031, 2046, 2047};
/* Dsitribution D4 */
#elif FRODO_DISTRIBUTION == FRODO_D4
#define FRODO_DISTRIBUTION_BITS 16
#define FRODO_CDF_LENGTH 7
const uint16_t CDF[FRODO_CDF_LENGTH] = {9651, 24351, 30841, 32500, 32745, 32766, 32767};
#endif


/* Structures for entropy generation */

/*
 * The structure FRODO_entropy_stripe use bit packing to parse the randomly
 * generated bytes into the required bits for the selected distribution.
 * The choice to use bit packing should not affect portability, as the order of
 * the fields in the struct is not relevant, since they are all randomly generated.
 */
#if FRODO_DISTRIBUTION_BITS == 8

#define FRODO_DISTRIBUTION_STEP 1
typedef struct __attribute__((__packed__)){
    uint8_t value :7;
    uint8_t sign  :1;
} FRODO_entropy_stripe;

#elif FRODO_DISTRIBUTION_BITS == 12

#define FRODO_DISTRIBUTION_STEP 3
// This entropy is used to generate two samples
typedef struct __attribute__((__packed__)){
    uint16_t value1 :11;
    uint8_t sign1   :1;
    uint16_t value2 :11;
    uint8_t sign2   :1;
} FRODO_entropy_stripe;

#elif FRODO_DISTRIBUTION_BITS == 16

#define FRODO_DISTRIBUTION_STEP 2
typedef struct __attribute__((__packed__)){
    uint16_t value :15;
    uint8_t sign   :1;
} FRODO_entropy_stripe;
#endif


/* Auxiliary macros for inverse sampling */

// Constant time conditional (on b) flip of the sign of x */
#define FRODO_I_SAMPLE_SIGN(x,b) ((-b)^x)+b
// Constant time comparison for x,v less than 2**15. It returns 1 if x < v, 0 otherwise */
#define FRODO_I_SAMPLE_CTCOMP(x,v) (uint16_t)(x-v)>>15

/* Fast CSPRNG for the generation */
void aes_ctr_init(FRODO_CSPRNG* RNG, FRODO_AES_CTX* aes_ctx_ptr)
{
    uint8_t key[FRODO_AES_BLOCK_SIZE];
    uint8_t iv[FRODO_AES_BLOCK_SIZE];

    for(int i = 0; i < FRODO_AES_BLOCK_SIZE; i++)
    {
        key[i] = FRODO_CSPRNG_GET(RNG);
        iv[i] = FRODO_CSPRNG_GET(RNG);
    }

    FRODO_AES_CTR_INIT(aes_ctx_ptr, key, iv);

    // Clean memory
    for(int i = 0; i < FRODO_AES_BLOCK_SIZE; i++)
    {
        key[i] = 0;
        iv[i] = 0;
    }
}

/* Inverse sampling function */
void FRODO_inverse_sample(FRODO_CSPRNG* RNG, uint16_t* samples, size_t n_samples)
{
    FRODO_AES_CTX aes_ctx;
    size_t n_random_bytes;
    uint8_t* entropy;

    // Compute required entropy
    n_random_bytes = n_samples * FRODO_DISTRIBUTION_STEP;
#if FRODO_DISTRIBUTION_STEP == 3
    n_random_bytes >>= 1;
#endif

    // Gather entropy
    aes_ctr_init(RNG, &aes_ctx);
    FRODO_AES_CTR_ENCRYPT_BUFFER(&aes_ctx, samples, n_random_bytes);
    FRODO_AES_CLEAN(&aes_ctx);

    // Start inverse sampling from the tail of the buffer
    entropy = (uint8_t*)samples + n_random_bytes - FRODO_DISTRIBUTION_STEP;
    samples += n_samples - 1;
#if FRODO_DISTRIBUTION_STEP == 3
    samples--;
#endif

#if FRODO_DISTRIBUTION_BITS == 8 || FRODO_DISTRIBUTION_BITS == 16
    uint16_t value;
    uint8_t sign;

    for(size_t i = 0; i < n_samples; i++)
    {
        value = ((FRODO_entropy_stripe*)entropy)->value;
        sign = ((FRODO_entropy_stripe*)entropy)->sign;
        *samples = 0;

        // Constant time comparison
        for(int j = 0; j < FRODO_CDF_LENGTH-1; j++)
        {
            *samples += FRODO_I_SAMPLE_CTCOMP(CDF[j], value);
        }

        // Restore sign of sample
        *(samples) = FRODO_I_SAMPLE_SIGN(*samples, sign);

        samples--;
        entropy -= FRODO_DISTRIBUTION_STEP;
    }
#elif FRODO_DISTRIBUTION_BITS == 12
    uint16_t value1, value2;
    uint8_t sign1, sign2;

    for(size_t i = 0; i < n_samples; i+=2)
    {
        value1 = ((FRODO_entropy_stripe*)entropy)->value1;
        value2 = ((FRODO_entropy_stripe*)entropy)->value1;
        sign1 = ((FRODO_entropy_stripe*)entropy)->sign1;
        sign2 = ((FRODO_entropy_stripe*)entropy)->sign2;
        *samples = 0;
        *(samples+1) = 0;


        // Constant time comparison
        for(int j = 0; j < FRODO_CDF_LENGTH-1; j++)
        {
            *samples += FRODO_I_SAMPLE_CTCOMP(CDF[j], value1);
            *(samples+1) += FRODO_I_SAMPLE_CTCOMP(CDF[j], value2);
        }

        // Restore sign of sample
        *samples = FRODO_I_SAMPLE_SIGN(*samples, sign1);
        *(samples+1) = FRODO_I_SAMPLE_SIGN(*(samples+1), sign2);

        samples -= 2;
        entropy -= FRODO_DISTRIBUTION_STEP;
    }
#endif
}

#ifdef HAS_MAIN
int main() {
    FRODO_CSPRNG RNG;
    char seed[100];

    for (int i=0;i<100;i++)
        seed[i] = i;
    RAND_seed(&RNG,100,seed);

    uint16_t samples[752*8] = {0};
    int counts[2*FRODO_CDF_LENGTH-1] = {0};
    int zero_pos = FRODO_CDF_LENGTH-1;

    FRODO_inverse_sample(&RNG,samples,752*8);

    for(int i=0;i<752*8;i++){
        counts[zero_pos+(int16_t)samples[i]]++;
    }

    printf("*** Samples distribution ***\n");
    for(int i=0;i<2*FRODO_CDF_LENGTH-1;i++){
        printf("# of samples for %d: %d\n",i-zero_pos,counts[i]);
    }

    return 0;
}
#endif
