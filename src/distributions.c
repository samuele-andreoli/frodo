/*
 * ISC License
 *
 * Copyright (c) 2019
 * Samuele Andreoli <samuele dot andreoli at studenti dot unitn dot it>
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "distributions.h"

/* Distributions configuration */

/* Dsitribution D1 */
#if FRODO_DISTRIBUTION == FRODO_D1
#define FRODO_DISTRIBUTION_BITS 8
#define FRODO_CDF_LENGTH 4
const uint16_t CDF[FRODO_CDF_LENGTH] = {43, 104, 124, 127};
/* Dsitribution D2 */
#elif FRODO_DISTRIBUTION == FRODO_D2
#define FRODO_DISTRIBUTION_BITS 12
#define FRODO_CDF_LENGTH 5
const uint16_t CDF[FRODO_CDF_LENGTH] = {784, 1774, 2022, 2046, 2047};
/* Dsitribution D3 */
#elif FRODO_DISTRIBUTION == FRODO_D3
#define FRODO_DISTRIBUTION_BITS 12
#define FRODO_CDF_LENGTH 6
const uint16_t CDF[FRODO_CDF_LENGTH] = {602, 1521, 1927, 2031, 2046, 2047};
/* Dsitribution D4 */
#elif FRODO_DISTRIBUTION == FRODO_D4
#define FRODO_DISTRIBUTION_BITS 16
#define FRODO_CDF_LENGTH 7
const uint16_t CDF[FRODO_CDF_LENGTH] = {9651, 24351, 30841, 32500, 32745, 32766, 32767};
#endif


/* Structures for entropy generation */

/* 
 * The structure FRODO_entropy_stripe use bit packing to parse the randomly
 * generated bytes into the required bits for the selected distribution.
 * The choice to use bit packing should not affect portability, as the order of
 * the fields in the struct is not relevant, since they are all randomly generated.
 */
#if FRODO_DISTRIBUTION_BITS == 8

#define FRODO_DISTRIBUTION_STEP 1
typedef struct __attribute__((__packed__)){
    uint8_t value :7;
    uint8_t sign  :1;
} FRODO_entropy_stripe;

#elif FRODO_DISTRIBUTION_BITS == 12

#define FRODO_DISTRIBUTION_STEP 3
// This entropy is used to generate two samples
typedef struct __attribute__((__packed__)){
    uint16_t value1 :11;
    uint8_t sign1   :1;
    uint16_t value2 :11;
    uint8_t sign2   :1;
} FRODO_entropy_stripe;

#elif FRODO_DISTRIBUTION_BITS == 16

#define FRODO_DISTRIBUTION_STEP 2
typedef struct __attribute__((__packed__)){
    uint16_t value :15;
    uint8_t sign   :1;
} FRODO_entropy_stripe;
#endif


/* Auxiliary macros for inverse sampling*/

// Constant time conditional (on b) flip of the sign of x */
#define FRODO_I_SAMPLE_SIGN(x,b) ((-b)^x)+b
// Constant time comparison for x,v less than 2**15. It returns 1 if x < v, 0 otherwise */
#define FRODO_I_SAMPLE_CTCOMP(x,v) (uint16_t)(x-v)>>15  

/* Inverse sampling function */
void FRODO_inverse_sample(csprng* RNG, uint16_t* samples, size_t n_samples)
{
    uint8_t entropy[FRODO_DISTRIBUTION_STEP];

#if FRODO_DISTRIBUTION_BITS == 8
    for(size_t i = 0; i < n_samples; i++)
    {
        // Get entropy
        *entropy = RAND_byte(RNG);

        // Constant time comparison
        for(int j = 0; j < FRODO_CDF_LENGTH-1; j++)
        {
            *samples += FRODO_I_SAMPLE_CTCOMP(CDF[j],((FRODO_entropy_stripe*)entropy)->value);
        }

        // Restore sign of sample
        *(samples++) = FRODO_I_SAMPLE_SIGN(*samples,((FRODO_entropy_stripe*)entropy)->sign);
    }
#elif FRODO_DISTRIBUTION_BITS == 12
    for(size_t i = 0; i < n_samples; i+=2)
    {
        // Get entropy
        *entropy = RAND_byte(RNG);
        *(entropy+1) = RAND_byte(RNG);
        *(entropy+2) = RAND_byte(RNG);

        // Constant time comparison
        for(int j = 0; j < FRODO_CDF_LENGTH-1; j++)
        {
            *samples += FRODO_I_SAMPLE_CTCOMP(CDF[j],((FRODO_entropy_stripe*)entropy)->value1);
            *(samples+1) += FRODO_I_SAMPLE_CTCOMP(CDF[j],((FRODO_entropy_stripe*)entropy)->value2);
        }

        // Restore sign of sample
        *samples = FRODO_I_SAMPLE_SIGN(*samples,((FRODO_entropy_stripe*)entropy)->sign1);
        *(samples+1) = FRODO_I_SAMPLE_SIGN(*(samples+1),((FRODO_entropy_stripe*)entropy)->sign2);
        samples+=2;
    }
#elif FRODO_DISTRIBUTION_BITS == 16
    for(size_t i = 0; i < n_samples; i++)
    {
        // Get entropy
        *entropy = RAND_byte(RNG);
        *(entropy+1) = RAND_byte(RNG);

        // Constant time comparison
        for(int j = 0; j < FRODO_CDF_LENGTH-1; j++)
        {
            *samples += FRODO_I_SAMPLE_CTCOMP(CDF[j],((FRODO_entropy_stripe*)entropy)->value);
        }

        // Restore sign of sample
        *(samples++) = FRODO_I_SAMPLE_SIGN(*samples,((FRODO_entropy_stripe*)entropy)->sign);
    }
#endif
}

#ifdef HAS_MAIN
int main() {
    csprng RNG;
    char seed[100];

    for (int i=0;i<100;i++)
        seed[i] = i*3;
    RAND_seed(&RNG,100,seed);

    uint16_t samples[100000] = {0};
    int counts[2*FRODO_CDF_LENGTH-1] = {0};
    int zero_pos = FRODO_CDF_LENGTH-1;

    FRODO_inverse_sample(&RNG,samples,100000);

    for(int i=0;i<100000;i++){
        counts[zero_pos+(int16_t)samples[i]]++;
    }

    printf("*** Samples distribution ***\n");
    for(int i=0;i<2*FRODO_CDF_LENGTH-1;i++){
        printf("# of samples for %d: %d\n",i-zero_pos,counts[i]);
    }

    return 0;
}
#endif
