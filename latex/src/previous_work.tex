In this chapter, some of the previous works in lattice-based cryptography and other post-quantum schemes are presented, to provide both an overview of the process that lead to the creation of New Hope and Frodo, and to draw the bigger picture in which these two protocols are placed in the search for post-quantum secure cryptographic primitives.

\section{The GGH cryptosystem}
The very first proposal of a Lattice-based primitive, in particular a Lattice-based trapdoor one-way function, is the GGH proposal \cite{GGH}. It presents a public key cryptosystem based on lattice-based primitives and dates back to 1997.\\
The private key for this cryptosystem is a basis $\mathbf{B}$ for a lattice $\mathscr{L}$, consisting of short, almost orthogonal vectors, while the public key is a generic basis $\mathbf{H}$ of the lattice, which can be efficiently computed from $\mathbf{B}$. In principle, there is no constraint on $\mathbf{H}$, but it is usually computed as the Hermit Normal Form of $\mathbf{B}$, since it makes computations easier.\\
Then, the trapdoor function itself is simply the addition of a short noise vector $\mathbf{r}$ to a vector $\mathbf{v}\in\mathscr{L}$, which encodes the message to transmit. The encoding $\mathbf{v}$ of a message $\mathbf{m}$ is simply the multiplication for the public key $\mathbf{H}$,  $\mathbf{v}=\mathbf{H}\mathbf{m}$. Recovering $\mathbf{r}$ from $\mathbf{r}+\mathbf{v}$ is an instance of the $\alpha$-BBH, which means that is computationally hard given a generic basis for the lattice, while it can be efficiently done, given the knowledge of the private key $\mathbf{B}$.
Moreover, recovering the basis $\mathbf{B}$, or an equivalently short basis, is an instance of the SIVP, so it is computationally hard as well.\\
The GGH trapdoor can also be used to sign a message by hashing it into $\mathbf{m}\in\mathbb{R}^n$ and then rounding it to the closest vector $\mathbf{s}\in\mathscr{L}$. The verification procedure is simply to verify the lattice membership of $\mathbf{s}$, which can be efficiently done with a generic basis for the lattice, and then to check that $\norm{\mathbf{s}-\mathbf{m}}$ is small. Indeed, producing the signature $\mathbf{s}$ is an instance of the CVP, so it can be efficiently done with the knowledge of the private key $\mathbf{B}$, but it is computationally hard with the sole knowledge of a generic basis for the lattice.\\
Although GGH is beautifully simple, it has quite a few drawbacks. Its security heavily relies on the choice of the private key $\mathbf{H}$ and of the distribution of the noise $\mathbf{r}$. Moreover, for attacks to be impractical the dimension of the lattice must be quite large. This is a huge problem for the practicality of this cryptosystem: because public keys are generic bases for the lattice $\mathscr{L}$, their dimension grows quadratically and they can not be efficiently compressed, making the memory requirements for the algorithm grow as $\Omega(n^2)$. This was the final nail in the coffin for the GGH cryptosystem, and started the search for trapdoor functions allowing a more compact representation.

\section{The NTRU proposal}
NTRU was first presented in 1998 by Hoffstein, Pipher and Silverman in \cite{NTRU}, but the cryptosystem has since undergone some modifications to improve efficiency and mitigate security concerns. In order to give an up-to-date definition of the cryptosystem, while still remaining somewhat faithful to the original definition, the formulation given by Micciancio and Regev in \cite{PQC} is a good compromise.\\
The lattices used in NTRU are convolutional modular lattices, which have a compact representation, as seen in Section \ref{sec:bg:ideal}. In this particular instance, $q$ is chosen to be not only even, but a power of $2$. The additional parameters required for NTRU are a weight bound $d_f$, which is a positive integer, and $p=3$.\\
Given these parameters, the private key for the NTRU cryptosystem are the short vectors $\mathbf{f},\mathbf{g}\in\mathbb{Z}^{n}$, which have to respect the following conditions:
\begin{itemize}
\item $\mathbf{T}^*\mathbf{f}$ should be invertible in $\mathbb{Z}^{n\times n}$;
\item $\mathbf{f}-\mathbf{e}_1$ and $\mathbf{g}$ must have exactly $d_f+1$ positive entries and $d_f$ negative entries;
\item $\mathbf{f}\in\mathbf{e}_1+\{0,\pm p\}^n$ and $\mathbf{g}\in\{0,\pm p\}^n$;
\end{itemize}
where $\mathbf{e}_1$ is the first canonical vector.
\sloppy The lattice associated to this public key is the one generated by $(\mathbf{T}^*\mathbf{f},\mathbf{T}^*\mathbf{g})^t$.\\
The public key can be derived from $\mathbf{f}$ and $\mathbf{g}$  as the block matrix
\begin{equation*}
\mathbf{H}=
\left[\begin{array}{c|c}
I_n & O \\
\hline
[\mathbf{T}^*[\mathbf{T}^*\mathbf{f}^{-1}]\mathbf{g}\text{ }mod\text{ }q] & qI_n
\end{array}\right]
\end{equation*}
Although this is a matrix in $\mathbb{Z}^{2n\times 2n}$, it is completely described by the vector \mbox{$\mathbf{h}=([\mathbf{T}^*\mathbf{f}^{-1}]\mathbf{g}\text{ }mod\text{ }q)\in\mathbb{Z}_q^n$}, which can be effectively transmitted instead of the full public key.\\
The encryption in NTRU requires the message to be encoded in $\mathbf{m}\in\{0,\pm1\}^n$ and an error vector $\mathbf{r}\in\{0,\pm1\}^n$. Both of these vectors need to respect the same bound on non-zero coefficients that holds for $\mathbf{f}$ and $\mathbf{g}$. Then, the encryption is given by $\mathbf{c}=\mathbf{v}-\mathbf{H}\lceil\mathbf{H}^{-1}\mathbf{v}\rfloor$, where $\mathbf{v}$ is the vector obtained vertically stacking $-\mathbf{r}$ and $\mathbf{m}$. The shape of $\mathbf{H}$ ensures that the first $n$ components of $\mathbf{c}$ are always zero, which means that for practical purposes it is enough to transmit the last $n$ components, which can be computed as $\mathbf{c}'=(\mathbf{m}+[\mathbf{T}^*\mathbf{h}]\mathbf{r})$ $mod$ $q$.\\
Then, the decryption is simply the multiplication by the secret matrix $[\mathbf{T}^*\mathbf{f}]$ modulo $q$, which yields $[\mathbf{T}^*\mathbf{f}]\mathbf{m} + [\mathbf{T}^*\mathbf{g}]\mathbf{r}$, followed by another reduction modulo $p$. This last reduction yields $\mathbf{m}$. Indeed, since $\mathbf{f}\in\mathbf{e}_1+\{0,\pm p\}^n$ and $\mathbf{g}\in\{0,\pm p\}^n$, then $[\mathbf{T}^*\mathbf{f}]=\mathbf{I}$ $mod$ $p$ and $[\mathbf{T}^*\mathbf{f}]=\mathbf{O}$ $mod$ $p$.\\
The NTRU cryptosystem can be extended to perform signatures in a similar fashion to GGH, and it is a strong candidate for a post quantum primitive, due to its efficiency. Indeed, the efficiency of the NTRU cryptosystem is remarkable, giving a compact representation of both private and public key as well as the ciphertext, reducing the memory requirements and bandwidth requirements to $O(n)$. At the same time, the choice of convolutional lattices makes the arithmetic really fast, making NTRU a really strong candidate.\\
Unfortunately, there is no comprehensive formal proof of security for NTRU, with only parts of the cryptosystem being backed by hard problems. Still, the cryptosystem is believed to be secure for an appropriate choice of parameters, although some attacks have been found for some of the proposed parameters choices.

\section{The BCNS proposal}
The following work on NTRU generated a remarkable interest in Ideal Lattices, seen as a way to make Lattice-based cryptosystem practical. It was during this period that Bos, Costello, Naehrig and Stebila presented a proposal for a post quantum key exchange, the BCNS proposal \cite{BCNS}.\\
The BCNS key exchange is a Diffie-Hellman-like unauthenticated key exchange using the RLWE trapdoor to generate public keys from a secret. The secret key is the vector $\mathbf{s}$ from the RLWE problem with short keys, and the public key is the corresponding $\mathbf{A}\mathbf{s}+\mathbf{e}$. Both of these keys require $n$ elements to be represented, although $\mathbf{s}$ could be compressed due to its shortness.\\
Then, the key exchange proceeds almost as a standard Diffie-Hellman, with the two parties exchanging the secret shares, i.e. the public keys, and recombining them. A regular Diffie-Hellman key exchange would terminate here, but the nature of RLWE requires two further steps.\\
First, one of the parties perturbs the recombined shares with a noise vector, and then it computes a hint, with an $help$ function. The nature of the $help$ changes depending on the key exchange, so it is not relevant for the sake of this overview. Second, and most important, the error correction. Indeed, because of the introduction of the noise vector $\mathbf{e}\xleftarrow{\$}\chi[\mathbb{Z}^{n\times\bar{n}}_q]$ in the public key, the recombined shares are perturbed in different ways for the two actors of the key exchange. Luckily, sampling the noise vector from an opportune Discrete Gaussian $\chi[\mathbb{Z}^{n\times\bar{n}}_q]$, it is possible to correct the error in the recombined shares with overwhelming probability, without affecting the security of the protocol.\\
In this step, the party who computed the hint will use a plain reconciliation function $rec$, while the other party will use a particular reconciliation function $rec\_hint$. This function factors in the hint to decide in which direction to round the error when undecided thus further reducing the probability of error in the reconciliation. \\
The complete key exchange is described in detail in Protocol \ref{prot:bcns}.\\
\begin{protocol}{BNCS}{Alice}{Bob}\label{prot:bcns}
$\mathbf{s},\mathbf{e}\xleftarrow{\$}\chi[\mathbb{Z}^{n\times\bar{n}}_q]$&$\mathbf{s'},\mathbf{e'}\xleftarrow{\$}\chi[\mathbb{Z}^{\bar{m}\times n_q}]$\\
&$\mathbf{e''}\xleftarrow{\$}\chi[\mathbb{Z}^{\bar{m}\times\bar{n}}_q]$\\
$\mathbf{b}\leftarrow\mathbf{As}+\mathbf{e}$&\\
$(\mathbf{b})\rightarrow$&\\
&$\mathbf{u}\leftarrow\mathbf{As'}+\mathbf{e'}$\\
&$\mathbf{v}\leftarrow\mathbf{b^ts'}+\mathbf{e''}$\\
&$\mathbf{r}\xleftarrow{\$}help(\mathbf{v})$\\
&$\leftarrow(\mathbf{u},\mathbf{r})$\\
$\mathbf{v'}\leftarrow\mathbf{us}$&\\
$\nu\leftarrow rec\_hint(\mathbf{v'},\mathbf{r})$&$\nu\leftarrow rec(\mathbf{v})$\\
\end{protocol}
\\
From the point of view of performance this cryptosystem fares quite well. The parameter $A$ can be represented by only $n$ elements as expected in the setting of Ideal Lattices and fixing it as a parameter of the protocol reduces the bandwidth required. The key size is $n$ both for private and public keys and, with the help of the NTT, the multiplications can be carried out in quasi-linear time. This makes the BCNS cryptosystem remarkably cheap. Moreover, the authors of \cite{BCNS} present a comprehensive formal proof of its security making this a really strong candidate.\\
The BCNS proposal has particular relevance for this work as both of the key exchanges presented, New Hope and Frodo, take this key exchange as their starting point. The former tries to improve on its security and efficiency while remaining in the setting of Ideal Lattices. The latter tries to reformulate it in the setting of Generic Lattices using the LWE problem.

\section{Non lattice-based PQC}
Lattice based primitives are not the only candidates to build post quantum public key cryptosystems. There are four main different areas of research other than Lattice-based cryptography: Multivariate cryptography, Hash based cryptography, Code based cryptography and Supersingular Elliptic Curve Isogeny cryptography. In this section they are quickly presented, with a particular focus to the relative performance w.r.t. Lattice-based cryptosystems.

\subsection{Multivariate Cryptography}
Multivariate cryptography is based on the MQ problem.
\begin{definition}[MQ Problem]
Given $m$ multivariate quadratic polynomials\\ \mbox{$\mathbf{p}_1(\mathbf{x}),\ldots,\mathbf{p}_m(\mathbf{x})$}, find a vector $\bar{\mathbf{x}}=(x_1,\ldots,x_n)$ $s.t.$ $\mathbf{p}_1(\bar{\mathbf{x}})=\ldots=\mathbf{p}_m(\bar{\mathbf{x}})=0$
\end{definition}
The core idea of cryptosystems based on the MQ problem is to trapdoor a system of polynomials as the one just described using two invertible linear maps to hide an easily invertible quadratic map. The public key is the composition of the three maps which results in a random looking system of polynomials. The private key is given by the three separate maps as they allow to easily invert the system in the public key.\\
If $\mathbf{P}$ is a public key, the encryption operation for a message $\mathbf{m}$ is the mapping of $\mathbf{m}$ through $\mathbf{P}$, $\mathbf{c}=\mathbf{P}(\mathbf{m})$. To decrypt the message it is enough to solve the system $\mathbf{P}(\mathbf{x})=\mathbf{c}$. It is immediate that solving such a system is equivalent to solve the MQ problem. This means that it is hard without the knowledge of the private key.\\
As far as performance are concerned, multivariate cryptosystems are relatively similar to Lattice-based ones. The operations are remarkably cheap to carry out, but the key size is quite large, being a system of multivariate polynomials.

\subsection{Code based Cryptography}
Code based cryptography is not a new concept. There are some early applications, like the McEliece cryptosystem presented in \cite{mceliece}, dating back to the seventies. They did not receive much attention at the time due to their impracticality on the systems available at the time as well as the relative performance w.r.t. cheaper cryptosystems, like RSA. Nevertheless, they became of interest when the search for post quantum cryptographic primitives started.\\
As suggested by the name these cryptosystem are based on error correcting linear codes. In particular, they base their security on the hardness of decoding a generic linear code. Knowing this, one can create a trapdoored generator matrix for said code, so that with the knowledge of this trapdoor the decoding is actually easy.\\
The private key is then a generator matrix $\mathbf{G}$ of some $(n,k,d)$-linear code $C$, for which an efficient decoding algorithm is known. This matrix is then scrambled using an invertible $k\times k$ matrix $\mathbf{A}$ and a $n\times n$ permutation matrix $\mathbf{P}$, obtaining the public key $\bar{\mathbf{G}}=\mathbf{SGP}$.\\
The encryption of a message $\mathbf{m}$ is simply the addition of an error vector $\mathbf{e}$, $s.t.$ $2w(\mathbf{e})+1\leq d$, to the encoded message $\mathbf{mSGP}$. The message is hard to decode given the generic $\bar{\mathbf{G}}$, but using the secret permutation inverse it is possible to use $\mathbf{G}$ to decode $\mathbf{mS}$\footnote{Since $\mathbf{P}$ is a permutation the weight of the error is unchanged by its application, making a correct decoding possible.}. Finally, applying $\mathbf{S}^{-1}$ yields the original message $\mathbf{m}$ thus completing the decryption.\\
Once again, it is easy to see that all of the operations used in these cryptosystems are extremely cheap. Indeed, the McEliece cryptosystem with the original parameters was faster than RSA itself. On the other hand, the public key is, once again, a matrix. This means that the bandwidth requirements for the presented cryptosystem grow as $O(nk)$, due to the dimension and rank of the linear code, while the memory requirements grow as $O(n^2)$, due to the dimension of the invertible matrix $\mathbf{S}$.

\subsection{SI Cryptography}
Supersingular Elliptic Curves Isogenies\footnote{SI from now on.} based cryptography is another promising field in the search for post quantum primitives.\\
In order to build an SI cryptosystem, one need a Supersingular elliptic curve $E$ over $\mathbb{F}_q$, and $S,R$ primitive points in the $\ell$-torsion group of the curve and $\ell'$-torsion group respectively. Remember that the $\ell$-torsion group of the curve is the group of points $P\in E[\mathbb{F}_q]$, $s.t.$ $\ell P=\mathscr{O}$. Using $E$ and $S,R$, the following commutative diagram can be defined

\[\begin{tikzcd}
E \arrow{r}{\phi} \arrow[swap]{d}{\psi} & E/\langle S \rangle \arrow{d}{\psi'} \\
E/\langle R \rangle \arrow{r}{\phi'} & E/\langle S,R \rangle
\end{tikzcd}
\]

where $\phi$ and $\psi$ are Isogenies.\\
The private key is composed by $E$ an $S$, which also determines $\phi$. The public key is given by $E$, $E/\langle S \rangle$, two generators $P,Q$ of the $\ell'$-torsion group and their image via $\phi$. In a similar fashion, a key pair can be constructed using $R$, $\psi$, and two generators.\\
With these key pairs, a Diffie-Hellman like key exchange can be defined. Each of the parties will use the mapping of $P,Q$ and the knowledge of the secret Isogenies, to compute the mappings of $P,Q$ in $E/\langle S,R \rangle$, thus completing the key exchange.\\
SI cryptography is very peculiar when it comes to performance. Unlike any other family of primitives presented until now, SI has remarkably small keys. This is not surprising, as it is common in ECC to have small key sizes. Unfortunately, SI cryptography shares another peculiarity with ECC. Indeed, the computational cost of SI cryptography is quite high making it costlier than any other scheme presented until now. 

\subsection{Hash based Cryptography}
Hash based cryptography is a family of cryptosystems based on the properties of hash functions with the most notable example being the Merkle Signature Scheme. This scheme is notorious for being the choice of the Bitcoin protocol for ensuring the transaction data integrity in a block. This family has a very robust proof of security depending only on the properties of hash functions and it is remarkably cheap in terms of computational cost. Unfortunately, it has only applications in digital signature schemes. This means that despite its notable properties it is only a competitor of Lattice-based cryptosystems when it comes to signature schemes.