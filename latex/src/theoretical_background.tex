\section{Lattices}

The starting point for Lattice-based cryptography is, quite evidently, lattices. The first part of this chapter focuses on giving an adequate background on lattices. For the sake of brevity and clarity, the following sections will focus on lattices on $\mathbb{R}^n$. Although lattices can potentially be defined using any vector space, this would overburden this introductory chapter with unnecessary notation, distracting the reader from the concepts necessary for building Lattice-based cryptographic primitives.

\subsection{Generic Lattices}\label{sec:bg:g_lattice}

\begin{definition}[Lattice]
Let $\{b_0,\ldots,b_{n-1}\}$ be a set of linearly independent vectors in $\mathbb{R}^m$, with $m\geq n$. The lattice generated by $\{b_0,\ldots,b_{n-1}\}$ is defined as the set of integer linear combinations of the $b_i$
\begin{equation*}
\mathscr{L}=\left\{\sum_{i=0}^{n-1}l_ib_i \mid l_i\in\mathbb{Z}\right\}
\end{equation*}
The set $B=\{b_0,\ldots,b_{n-1}\}$ is called a basis of the lattice, $n$ is called lattice rank, and $m$ lattice dimension. If $m=n$, the lattice is said to be a full rank lattice.
\end{definition}

\begin{definition}[Span of a Lattice]
Let $\mathscr{L}$ be a lattice and $\mathbf{B}$ a basis for $\mathscr{L}$. The span of the lattice is defined as the linear space spanned by its vectors:
\begin{equation*}
\mathrm{span}(\mathscr{L}) = \mathrm{span}(B) = \{B\mathbf{x}\mid\mathbf{x}\in\mathbb{R}^n\}
\end{equation*} 
\end{definition}

\begin{remark}
It is immediate that given two lattices $\mathscr{L}$, $\mathscr{L}'$, then $\mathscr{L}\subset \mathscr{L}' \Rightarrow \mathrm{span}(\mathscr{L}) \subset \mathrm{span}(\mathscr{L}')$.
\end{remark}

It is worth introducing an alternative notation for lattices. Let us consider the matrix $\mathbf{B}$, with columns $b_0,\ldots,b_{n-1}$. It is easy to see that the lattice generated by $b_0,\ldots,b_{n-1}$ is the set $\mathscr{L}=\{\mathbf{Bv}\mid\mathbf{v}\in\mathbb{Z}^n\}$.\\
Moreover, all of the lattices interesting for Lattice-based cryptography are full rank lattices, so from now onwards whenever a lattice is mentioned, it will be assumed to be full rank, i.e. $\mathscr{L}\subset\mathbb{R}^n$.\\
Let us introduce some useful notions on lattices.

\begin{definition}[Minimum distance]
The minimum distance of a lattice $\mathscr{L}$ is defined as the minimum distance between any two lattice points
\begin{equation*}
\lambda = min\{\norm{\mathbf{x}-\mathbf{y}}\mid\mathbf{x}\ne \mathbf{y}, \mathbf{x},\mathbf{y}\in\mathscr{L}\}
\end{equation*}
Since a lattice is an addictive subgroup of $\mathbb{R}^n$, the above definition is equivalent to
\begin{equation*}
min\{\norm{\mathbf{x}}\mid\mathbf{x}\ne0, \mathbf{x}\in\mathscr{L}\}
\end{equation*}
\end{definition}

The previous definition can be generalized to a set of linearly independent vectors as follows
\begin{definition}[i-th Successive Minimum]
The i-th successive minimum of a lattice is defined as 
\begin{equation*}
\lambda_i = min\{r \in \mathbb{R}\mid\exists \{\mathbf{v_i}\}_{i=0}^{n-1} \subset \mathscr{L},\text{ }linearly\text{ }independent,\text{ }s.t.\text{ }\forall i,\norm{\mathbf{v_i}}\leq r\}.
\end{equation*}
\end{definition}

\begin{remark}
It is immediate to see that $\lambda=\lambda_0$
\end{remark}

\begin{definition}[Dual Lattice]
The dual lattice $\mathscr{L}^*$ of a lattice $\mathscr{L}$ is defined as the set
\begin{equation*}
\mathscr{L}^*=\{\mathbf{w}\in\mathbb{R}^n\mid\forall\mathbf{x}\in\mathscr{L},\langle\mathbf{w},\mathbf{x}\rangle\in\mathbb{Z}\}.
\end{equation*}
\end{definition} 

\begin{theorem}
Let $\mathscr{L}$ be a lattice, and $\mathbf{B}$ its basis, then the matrix $\mathbf{D}=\mathbf{B}(\mathbf{B}^{t}\mathbf{B})^{-1}$ is a basis for $\mathscr{L}^*$
\end{theorem}
\begin{proof}
Let us call $\tilde{\mathscr{L}}$ the lattice generated by $\mathbf{D}$.\\
First of all, $\forall{\mathbf{Dy}} \in \tilde{\mathscr{L}}$, it holds
\begin{equation*}
\mathbf{Dy} = (\mathbf{B}(\mathbf{B}^{t}\mathbf{B})^{-1})\mathbf{y} = \mathbf{B}(\mathbf{B}^{t}\mathbf{B})^{-1}\mathbf{y}) \in \mathrm{span}(\mathscr{L}),
\end{equation*}
moreover, $\forall \mathbf{Bx}\in\mathscr{L}$,
\begin{equation*}
\begin{aligned}
\langle \mathbf{By},\mathbf{Bx} \rangle = (\mathbf{Dy})^{t}\mathbf{Bx} = \mathbf{y}^{t} (\mathbf{B}^t\mathbf{B})^{-1}\mathbf{B}^t\mathbf{B}\mathbf{x}\\
= \mathbf{y}^{t} \mathbf{B}^{-1}(\mathbf{B}^t)^{-1}\mathbf{B}^t\mathbf{Bx} = \mathbf{y}^t\mathbf{x} \in \mathbb{Z}^n,
\end{aligned}
\end{equation*}
since $\mathbf{x}$ and $\mathbf{y}$ are vectors of coefficients for elements of the lattices $\mathscr{L}$ and $\tilde{\mathscr{L}}$. Then $D\mathbf{y}\in\mathscr{L}^*$, which means that $\tilde{\mathscr{L}}\subset\mathscr{L}^*$.\\
Now, consider $\mathbf{v}\in\mathscr{L}^*$. By definition of dual, $\mathbf{B}^t\mathbf{v}\in\mathbb{Z}^n$. As stated above, it also holds that $\mathbf{v}\in \mathrm{span}(\mathscr{L})$, which means that $\exists\mathbf{w}\in\mathbb{R}^n$ $s.t.$ $\mathbf{v}=\mathbf{Bw}$. Then
\begin{equation*}
\mathbf{v} = \mathbf{Bw} = \mathbf{B}(\mathbf{B}^t\mathbf{B})^{-1}\mathbf{B}^t\mathbf{B}\mathbf{w} = \mathbf{DB}^t\mathbf{v} \in \mathscr{L}^*,
\end{equation*}
since $\mathbf{B}^t\mathbf{v}\in\mathbb{Z}^n$, which means that $\mathscr{L}^*\subset\tilde{\mathscr{L}}$ thus concluding the proof.
\end{proof}

\begin{definition}[Fundamental Parallelepiped]
Given a lattice $\mathscr{L}$, and $\mathbf{B}$ a basis for $\mathscr{L}$, the fundamental parallelepiped of $\mathscr{L}$ is defined as the set
\begin{equation*}
\mathscr{P} = \{\mathbf{Bx}\mid\mathbf{x}\in\mathbb{R}^n, \forall i \in \{0,\ldots,n-1\}:0\leq x_i \leq 1 \}.
\end{equation*}
\end{definition}

\begin{remark}
The fundamental parallelepiped is quite a useful concept in lattices. Indeed, it is easy to see that placing a fundamental parallelepiped at every vector of the lattice $\mathscr{L}$, it is possible to tessellate the entirety of $\mathrm{span}(\mathscr{L})$.
\end{remark}

\begin{definition}[Voronoi Cell]
Given a lattice $\mathscr{L}$, and $\mathbf{B}$ a basis for $\mathscr{L}$, the Voronoi cell of $\mathscr{L}$, with center in $\mathbf{y}\in\mathscr{L}$ is defined as the set
\begin{equation*}
\mathscr{V}_\mathbf{y} = \{\mathbf{x}\in\mathbb{R}^n\mid\forall \mathbf{y}' \in \mathscr{L}\backslash\mathbf{y}, \norm{\mathbf{x}-\mathbf{y}} < \norm{\mathbf{x}-\mathbf{y}'} \}.
\end{equation*}
The fundamental Voronoi cell is defined as $\mathscr{V}_0$. 
\end{definition}

\begin{remark}
The geometry of the Voronoi cell depends on the metric used over $\mathbb{R}^n$. For the purpose of Lattice-based cryptography, this metric will always be the euclidean distance. So, from now onwards, any time a Voronoi cell is mentioned, it will be intended as the Voronoi cell computed using the euclidean distance.
\end{remark}

The concept of Voronoi cell is especially important for Lattice-based cryptography. The nature of this importance will be discussed in more detail later.\\
All of these definitions apply to Generic Lattices, but there are some subclasses of lattices that are of particular interest for Lattice-based cryptography. Let us explore some of the concepts that will become relevant in the applications.

\begin{definition}[\text{$q$}-ary Lattice]
Let $\mathscr{L}\subset\mathbb{Z}^n$ be a lattice. $\mathscr{L}$ is said $q$-ary for some $q\in\mathbb{Z}^n$, if $q\mathbb{Z}\subset\mathscr{L}$.
\end{definition} 

\begin{remark}
If $\mathscr{L}$ is a $q$-ary lattices, and $\mathbf{x}\in\mathscr{L}$ a vector, then $\mathbf{x}+q\mathbb{Z}^n\in\mathscr{L}$, since $q\mathbb{Z}\subset\mathscr{L}$ and $\mathscr{L}$ is an additive group. This means that $\forall\mathbf{x}\in\mathbb{Z}^n, \mathbf{x}\in\mathscr{L}\Leftrightarrow\mathbf{x}$ $\mathrm{mod}$ $q\in\mathscr{L}$.
\end{remark}

This family of lattices is quite important in applications, where there is a need to deal with finite precision, making lattices over $\mathbb{Z}^n$ quite difficult to manage. With $q$-ary lattices it is possible to reduce the problem of Lattice Membership of $\mathbf{x}\in\mathbb{Z}^n$ to the much easier and compact problem of Lattice Membership of $\mathbf{x}$ $\mathrm{mod}$ $q$.\\
The other families of lattices fall, in some way or another, under the polyhedric family that is the one of Ideal Lattices, which is explored in the next section.

\subsection{Ideal Lattices}\label{sec:bg:ideal}

Following the same spirit of the premise made at the beginning of the chapter, the definition and properties of Ideal Lattices will not be enunciated in general terms. They will be restricted to the cases relevant in the construction of lattice based primitives. This section follows the approach to Ideal Lattices adopted in \cite{ideal_lattices}, adapting it to the more restrictive setting.

\begin{definition}[Ideal Lattice]
$\mathscr{L}$ is said to be an Ideal Lattice, if it is an ideal of a ring of the form $\mathbb{Z}[x]/(f)$, where $f\in\mathbb{Z}[x]$ is monic.\\
\end{definition}

For their importance in applications, one particular family of Ideal Lattices deserves to be introduced.

\begin{definition}[Cyclic Lattice]
$\mathscr{L}$ is said to be a Cyclic Lattice, if it is an ideal of a ring of the form $\mathbb{Z}[x]/(x^n-1)$, where $f\in\mathbb{Z}[x]$ is a monic polynomial.\\
\end{definition}

It is possible to give an alternative formulation for Ideal Lattices, as presented in \cite{PQC}, which makes their geometry more intuitive and explains how they relate to General Lattices.\\
Consider the monic polynomial $f\in\mathbf{Z}[x]$, $f=x^n+f_{n-1}x^n-1 + f_0$. From $f$ it is possible to define the linear transformation
\begin{equation*}
\mathbf{F}=
\left[\begin{array}{ccc|c}
0&\cdots&0&\multirow{4}{*}{$-f$}\\
\cline{1-3}
&&&\\
&I_{n-1}&&\\
&&&
\end{array}\right].
\end{equation*}

Using this transformation it is possible to define a matrix $\mathbf{B}$ for each $\mathbf{b}\in\mathbb{Z}^n$ as
\begin{equation*}
\mathbf{B}=[\mathbf{F}^*\mathbf{b}]=\left[\mathbf{F}^{i}\mathbf{b}\right]_{i=0}^{n-1},
\end{equation*}
where $\mathbf{F}^0=I_n$. Using the matrix $\mathbf{B}$ one can generate an Ideal Lattice in $\mathbb{Z}[x]/(f)$.\\
With this alternative representation it becomes evident why the Cyclic Lattices have this name. Indeed, they are defined as the ideals of the ring $\mathbb{Z}[x]/(x^n-1)$. This means that the associated transformation is
\begin{equation*}
\mathbf{T}=
\left[\begin{array}{ccc|c}
0&\cdots&0&1\\
\cline{1-3}
&&&0\\
&I_{n-1}&&\vdots\\
&&&0
\end{array}\right].
\end{equation*}
This transformation is nothing more than the circulant shift of a vector components by one position. This means that the resulting basis for the lattice is a circulant matrix.\\
Finally, using this transformation it is easy to give the definition of one last family of Ideal Lattices important in the applications.
\begin{definition}[Convolutional Modular Lattices]
Let $\mathscr{L}$ be a lattice in $\mathbf{Z}[x]/(x^{2n}-1)$. $\mathscr{L}$ is said to be a Convolutional Modular Lattice if it is a $q$-ary lattice and it is closed under the linear transformation
\begin{align*}
\mathbb{Z}^{2n}&\rightarrow \mathbb{Z}^{2n} \\
(\mathbf{x}\mid\mathbf{y}) &\mapsto (\mathbf{Tx}\mid\mathbf{Ty}),
\end{align*}
where $\mathbf{T}$ is the linear transformation defined above.
\end{definition}
\begin{remark}
The transformation $(\mathbf{x}\mid\mathbf{y}) \mapsto (\mathbf{Tx}\mid\mathbf{Ty})$ can be intuitively seen as the circular shifts of the two vector halves being carried out in parallel.
\end{remark}

Moreover, the alternative formulation makes one of the advantages of Ideal Lattices staggeringly clear. Indeed, once fixed the ring $\mathbb{Z}[x]/(f)$, the representation of an Ideal Lattice only requires the vector $b\in\mathbb{Z}^n$, instead of the full matrix $\mathbf{B}$. This reduces the bandwidth necessary to transmit the lattice representation from $n^2$ to $n$ thus eliminating one of the main drawbacks of Lattice-based cryptography.\\
Moreover, by interpreting the elements of the lattice and the vector $b$ as polynomials, all of the operations on lattices can be reinterpreted as polynomial operations. This has a huge implication, as the matrix $\mathbf{B}$ is not required to perform this kind of operations thus making the memory requirements grow as $O(n)$ even during the computations.\\
Still, polynomial multiplications are not exactly a fast operation if performed naively. Luckily, for lattices in $\mathbb{Z}_q^n[x]/(f)$, it is possible to speed up these operations using the Number Theoretical Transform, which allows to convert polynomial multiplication in simple component-wise multiplications between arrays. This will be explored in detail is Section \ref{sec:bg:ntt}.

\section{Noise Distributions}
Lattice-based cryptography schemes heavily rely on short random vector, typically sampled from a Discrete Gaussian distribution, used to perturb lattice elements. This section introduces a few relevant concepts on this topic.\\

\begin{definition}[Gaussian Measure]
Consider $\mathbf{x},\mathbf{c}\in\mathbb{R}^n$, and $s>0$. The Gaussian measure is defined as
\begin{equation*}
\rho_{s,\mathbf{c}}(\mathbf{x}) = exp\left[\frac{-\pi\norm{\mathbf{x}-\mathbf{c}}^2}{s^2}\right].
\end{equation*}
\end{definition}

The total measure associated to $\rho_{s,\mathbf{c}}$ can be computed as $\int_{\mathbf{x}\in\mathbb{R}^n}\rho_{s,\mathbf{c}}(\mathbf{x})d\mathbf{x}$ $=$ $s^n$. The, the Continuous Gaussian Distribution of parameter $s$ and centered in $\mathbf{c}$ can be defined as follows.

\begin{definition}[Gaussian Distribution]
Consider $\mathbf{x},\mathbf{c}\in\mathbb{R}^n$, and $s>0$. The Continuous Gaussian Distribution is defined as
\begin{equation*}
D_{s,\mathbf{c}}(\mathbf{x})=\frac{\rho_{s,\mathbf{c}}(\mathbf{x})}{s^n}.
\end{equation*}
\end{definition}

This distribution would already be sufficient to sample noise efficiently as it is easy to see that it is the sum of $n$ orthogonal one dimensional Gaussian distributions. This means that it can be approximated with arbitrary precision using known techniques. However, it is worth spending some time to define a discrete counterpart which can be more efficiently sampled when only a finite precision is available. The first step required to reach this goal is to define the Gaussian mass of a lattice $\mathscr{L}$.

\begin{definition}[Gaussian Mass]
Let $\mathscr{L}$ be a lattice, $\mathbf{c}\in\mathbb{R}^n$ and consider $s>0$. The Gaussian mass of $\mathscr{L}$ is defined as
\begin{equation*}
R_{s,\mathbf{c}}(\mathscr{L})=\sum_{\mathbf{y}\in\mathscr{L}}\rho_s(\mathbf{y}),
\end{equation*}
where $\mathbf{y}\in\mathscr{L}$
\end{definition}

Using the concepts of Gaussian mass and Gaussian measure, the Discrete Gaussian Distribution $D_{\mathscr{L},s}$ can be formulated as follows.

\begin{definition}[Discrete Gaussian Distribution]
Let $\mathscr{L}$ be a lattice, $\mathbf{c}\in\mathbb{R}^n$ and consider $s>0$. The Discrete Gaussian Distribution of parameter $s$ and center $\mathbf{c}$ over $\mathscr{L}$ is the distribution induced by the measure
\begin{equation*}
\mathbb{D_{s,\mathbf{c},\mathscr{L}}}(\mathbf{x})= \frac{\rho_{s,\mathbf{c}}(\mathbf{x})}{R_{s,\mathbf{c}}(\mathscr{L})}.
\end{equation*}
\end{definition}

\begin{remark}
Although the discrete Gaussian Distribution behaves differently from the continuous one, it can be proved that for a large enough $s$ they start behaving similarly. How large $s$ needs to be is determined by the smoothing parameter of a lattice.
\end{remark}

\begin{definition}[Smoothing parameter]
Let $\mathscr{L}$ be a lattice and consider $\epsilon>0$, the smoothing parameter $\eta_\epsilon(\mathscr{L})$ is defined as the smallest $s$, $s.t.$ $\rho_{s^-1}(\mathscr{L}^*\backslash\{0\})<\epsilon$
\end{definition}

Unfortunately, computing the smoothing parameter of a lattice is often impractical. However, for application purposes, having a higher bound of the smoothing parameter is enough.

\begin{theorem}
Let $\mathscr{L}$ be a lattice, and take $\epsilon=2^{-n}$. It holds
\begin{equation*}
\eta_\epsilon(\mathscr{L})\leq\frac{\sqrt{n}}{\lambda\left(\mathscr{L}\right)}.
\end{equation*}
\end{theorem}

Although both tighter and more general bounds are known on the smoothing parameters, this bound is more than adequate to use when choosing the parameters of a Lattice based Cryptosystem. Indeed, it is the most widespread in literature and it is used by the authors of all the cryptosystems presented in this work when justifying their parameter choice.

\section{NTT}\label{sec:bg:ntt}

The NTT is a powerful instrument in improving the efficiency of Lattice-based cryptography in the setting of Ideal Lattices on $\mathbb{Z}_q^n$. As seen in Section \ref{sec:bg:ideal}, one of the drawbacks of Ideal Lattices is the cost of polynomial multiplications. For the sake of exposition, in this section the polynomials in $\mathbb{Z}_q[x]/(f)$, where $f$ is a primitive polynomial $s.t.$ $deg(f)=n$ will be identified with the vectors of their coefficients in $\mathbb{Z}_q^n$. Using the NTT on these representations, it is possible to compute the polynomial products with a cheap component-wise product, using then the inverse transform to restore the coefficients in $\mathbb{Z}_q^n$.\\

Let us see how the NTT works. In a nutshell, it is a specialized from of the Discrete Fourier Transform that works on number fields. Indeed, the DFT works on complex vectors as follows.

\begin{definition}
Let $\mathbf{x}\in\mathbb{C}^n$, the DFT of $\mathbf{x}$ is defined as
\begin{equation*}
DFT(\mathbf{x})=\left(\sum_{m=0}^{n-1}x_me^{-ikm2\pi/n} \right)_{i=0}^{n-1}.
\end{equation*}
\end{definition}

The core idea to bring this notion to number fields, is to replace the term $e^{-i2\pi/n}$, which is a primitive $n$-th root of unity, with some integer $W_n$, which is itself a primitive $n$-th root of the unity in the considered number field.\\
For the sake of brevity and clarity, the considered number field will be $\mathbb{Z}_q^n$, with $q$ prime, so that $\mathbb{Z}_q$ is assured to have at least one primitive $n$-th root of unity, as long as $n\mid(q-1)$, i.e. it is just a matter of parameter choice.

\begin{definition}[NTT]
Let $\mathbf{x}\in\mathbb{Z}_q^n$, $q$ prime, and $W_n\in\mathbb{Z}_q$ an $n$-th root of unity. Then, the NTT of $\mathbf{x}$ is defined as
\begin{equation*}
NTT(\mathbf{x})=\left(\sum_{m=0}^{n-1}x_mW_n^{km}\text{ }\mathrm{mod}\text{ }q,\text{ }\right)_{k=0}^{n-1}.
\end{equation*}
The inverse transform, can then be computed as
\begin{equation*}
NTT^{-1}(\mathbf{x})=\left(n^{-1}\sum_{m=0}^{n-1}x_mW_n^{-km}\text{ }\mathrm{mod}\text{ }q,\text{ }\right)_{k=0}^{n-1}.
\end{equation*} 
\end{definition}

\begin{remark}
The NTT can be formulated alternatively defining the matrix $W=[W_n^{km}$ $\mathrm{mod}$ $q]_{(k,m)\in\{0,\ldots,n-1\}\times\{0,\ldots,n-1\}}$. With the matrix $\mathbf{W}$, the NTT of $\mathbf{x}\in\mathbb{Z}_q^n$ can be computed as $\mathbf{Wx}$.
\end{remark}

Although the NTT does not have the same frequency interpretation of the DFT, it still has some similar properties. The most interesting property from the point of view of Lattice-based cryptography is the convolutional product, which behaves similarly to the one defined for the DFT.

\begin{definition}[Circular Convolution]
Let $\mathbf{x},\mathbf{y}\in\mathbb{Z}_q^n$, $q$ prime. Then, the convolution of $\mathbf{x}$ and $\mathbf{y}$ is defined as
\begin{equation*}
\mathbf{x}\ast\mathbf{y} = \left(\sum_{m=0}^{n-1}x_{m}y_{(k-m)}\right)_{k=0}^{n-1},
\end{equation*}
where $\forall i \in \{1,\ldots,n-1\} y_{-i}$ is defined as $y_{n-i-1}$. 
\end{definition}

\begin{theorem}[Convolutional product]
Let $\mathbf{x},\mathbf{y}\in\mathbb{Z}_q^n$, $q$ prime. Then
\begin{equation*}
\mathbf{x}\ast\mathbf{y} = \mathrm{NTT}^{-1}(\mathrm{NTT}(\mathbf{x}) \circ \mathrm{NTT}(\mathbf{y})).
\end{equation*}
\end{theorem}
\begin{proof}
Let us consider two arbitrary $\mathbf{x},\mathbf{y}\in\mathbb{Z}_q^n$. Then
\begin{equation*}
\begin{aligned}
\mathrm{NTT}(\mathbf{x}\ast\mathbf{y}) = \mathrm{NTT}\left(\left(\sum_{m=0}^{n-1}x_{m}y_{(k-m)}\right)_{k=0}^{n-1}\right)\\
= \left(\sum_{i=0}^{n-1}\sum_{m=0}^{n-1}x_my_{(i-m)}W_n^{ik}\right)_{k=0}^{n-1}\\
= \left(\sum_{m=0}^{n-1}\sum_{i=0}^{n-1}x_my_{(i-m)}W_n^{ik}\right)_{k=0}^{n-1}\\
= \left(\sum_{m=0}^{n-1}x_m\sum_{i=0}^{n-1}y_{(i-m)}W_n^{(i-m)k}W_n^{mk}\right)_{k=0}^{n-1}\\
= \left(\sum_{m=0}^{n-1}x_mW_n^{mk}\sum_{i=0}^{n-1}y_{(i-m)}W_n^{(i-m)k}\right)_{k=0}^{n-1}\\
= \left(\mathrm{NTT}(\mathbf{x})_k\mathrm{NTT}(\mathbf{y})_k\right)_{k=0}^{n-1} = \mathrm{NTT}(\mathbf{x})\circ \mathrm{NTT}(\mathbf{y}).
\end{aligned}
\end{equation*}
Applying the inverse NTT transform to both sides of the equality yields the wanted result.
\end{proof}

This is already a step in the right direction as it is already possible to compute the product of two polynomials with the convolutional product. On the other hand, for the circular convolution to yield the product of two polynomials, the vectors of coefficients fed into it need to be padded with n zeros, thus requiring the convolution of vectors of dimension $2n$. This issue can be solved by using the negative wrapped convolution.

\begin{definition}[Negative Wrapped Convolution]
Let $\mathbf{x},\mathbf{y}\in\mathbb{Z}_q^n$, $q$ prime, and $\psi$ a $2n$-th root of unity. Then, the negative wrapped convolution of $\mathbf{x}$ and $\mathbf{x}$ is defined as
\begin{equation*}
\mathbf{x}\circledast\mathbf{y} = (\psi^{-i})_{i=0}^{n-1}\circ \mathrm{NTT}^{-1}(\mathrm{NTT}(\mathbf{x})\circ \mathrm{NTT}(\mathbf{y})).
\end{equation*}
\end{definition}

Finally, with the Negative Wrapped Convolution, a polynomial product is successfully transformed into $n$-dimensional NTT transforms and component-wise multiplications.

\section{Hard problems in Lattices}\label{sec:bg:prob}
In this section are introduced the hard problems behind the security of Lattice-based cryptography primitives. None of the additional structure of Ideal Lattices is used in the definition of these problems, making these definitions valid both for generic and Ideal Lattices.\\
It is worth pointing out that the following problems are hard\footnote{Under the assumption of an opportune parameters choice}, unless a Basis of the Lattice with particular properties is known. This can already hint to the definition of cryptographic primitives based on said problems. Such basis could effectively be used as a private key, making a generic basis for the Lattice the corresponding public key.

\subsubsection{SVP}

The main formulation for the SVP is the search problem defined as follows.

\begin{definition}[Search Shortest Vector Problem (SVP)]
Let $\mathscr{L}$ be a Lattice, and $\mathbf{B}$ a basis for $\mathscr{L}$, the SVP consists in finding $\mathbf{v}\in\mathscr{L}$ $s.t.$ $\norm{\mathbf{v}} = \lambda$, where $\lambda$ is the minimum distance of the Lattice $\mathscr{L}$.
\end{definition}

It is also possible to give a decisional formulation, defined as follows.

\begin{definition}[Decisional SVP]
Let $\mathscr{L}$ be a Lattice, and $\mathbf{B}$ a basis for $\mathscr{L}$, given $\mathbf{v}\in\mathscr{L}$, determine if $\norm{\mathbf{v}} = \lambda$.
\end{definition}

The SVP problem can also be generalized as follows.

\begin{definition}[Shortest Independent Vectors Problem (SIVP)]
Let $\mathscr{L}$ be a lattice, and $\mathbf{B}$ a basis for $\mathscr{L}$, find a set $S={s_i}_{i=0}{n-1}\subset \mathscr{L}$ of linearly independent vectors $s.t$ $\forall i$ $\norm{\mathbf{s_i}} = \lambda_i$, where $\lambda_i$ is the i-th successive minimum of the lattice $\mathscr{L}$.
\end{definition}

Moreover, it is worth introducing the approximate problems $SVP_\gamma$, $SIVP_\gamma$ and $GapSVP_\gamma$, which are often more useful in security reductions than the exact counterpart.

\begin{definition}[Approximate SVP]
Let $\mathscr{L}$ be a lattice, $\mathbf{B}$ a basis for $\mathscr{L}$, and $\gamma(n)\geq1$ the approximation factor, find a $\mathbf{v}\in\mathscr{L}\backslash0$ $s.t.$ $\norm{\mathbf{v}} \leq \gamma(n)\lambda$.
\end{definition}

\begin{definition}[\text{Approximate SIVP (SIVP$_\gamma$)}]
Let $\mathscr{L}$ be a lattice, $\mathbf{B}$ a basis for $\mathscr{L}$, and $\gamma(n)\geq1$ the approximation factor, find a set $S={s_i}_{i=0}{n-1}\subset \mathscr{L}$ of linearly independent vectors $s.t$ $\forall i$ $\norm{\mathbf{s_i}} \leq \gamma(n)\lambda_i$.
\end{definition}

\begin{definition}[\text{Approximate Decisional SVP (GapSVP$_\gamma$)}]
Let $\mathscr{L}$ be a lattice, $\mathbf{B}$ a basis for $\mathscr{L}$, and $\gamma(n)\geq1$ the approximation factor, tell which holds between $\lambda\leq1$ or $\lambda > \gamma(n)$.
\end{definition}
\begin{remark}
An algorithm to solve the GapSVP$_\gamma$ is allowed to error if neither of the options are true.
\end{remark}

\subsubsection{CVP}
The CVP problem family is closely related to the SVP. Indeed, it can be seen as a generalization of it.

\begin{definition}[Search CVP]
Let $\mathscr{L}$ be a lattice, $\mathbf{B}$ a basis for $\mathscr{L}$, and a vector $\mathbf{v}\in\mathscr{\mathbb{R}^n}$, find the vector $\mathbf{w}\in\mathscr{L}$ $s.t.$ $\forall\mathbf{y}\in\mathscr{L},\norm{\mathbf{v}-\mathbf{w}} < \norm{\mathbf{v}-\mathbf{y}}$.
\end{definition}

Similarly to the SVP, there are alternative formulations such as the Decisional and Approximate SVP. All of them can be derived as they were in the SVP setting.

\subsubsection{BDD}

\begin{definition}[\text{Bounded Distance Decoding ($\alpha$-BDD)}]
Let $\mathscr{L}$ be a lattice, $\mathbf{B}$ a basis for $\mathscr{L}$, $\alpha\in[0,1]$, and $\mathbf{t}\in\mathbb{R}^n$. Assuming that $\exists \mathbf{y}\in\mathscr{L},\norm{\mathbf{t}-\mathbf{y}} < \alpha\lambda$, find the unique lattice vector $\mathbf{v}\in\mathscr{L}$ $s.t.$ $\norm{\mathbf{t}-\mathbf{v}}<\alpha\lambda$.
\end{definition}

\begin{remark}
An algorithm to solve the $\alpha$-BDD is allowed to error if the bound on the distance is not satisfied.
\end{remark}

\subsubsection{SIS}

\begin{definition}[Short Integer Solution Problem]
Given $B\in\mathbb{Z_q^{m\times n}}$, and $\alpha > 0$, find $\mathbf{x}\in[-\alpha,\alpha]^m\backslash{0}$, $s.t.$ $B\mathbf{x}=0$ $\mathrm{mod}$ $q$.
\end{definition}

\begin{remark}
An approximate formulation of SIS is possible and useful, while the decisional formulation is not an hard problem so it is not to be used.
\end{remark}

\section{LWE and RLWE}
In this section the scope of this presentation will be further narrowed to better introduce these two problems in light of their applications. Indeed, all of the lattices considered from now onwards are going to be $q$-ary lattices. At the end of Section \ref{sec:bg:g_lattice} it was mentioned that in the setting of $q$-ary lattices, i.e. $\mathbf{x}\in\mathscr{L}\Leftrightarrow\mathbf{x}$ $\mathrm{mod}$ $q\in\mathscr{L}$. Then it is possible to identify such lattices with their counterpart over $\mathbb{Z}_q^n$. This will be the setting for the next two sections. This change is quite beneficial when considering the application as having bounded coefficients for the lattice elements allows smaller representations and saves the considerable burden of dealing with  multiprecision integer computations. \\

\subsection{The LWE problem}
The LWE problem has been one of the first candidates to provide a base for practical lattice-based cryptographic primitives. As mentioned in Section \ref{sec:bg:prob}, most of the problem introduced until now would yield cryptographic primitives having a basis of the lattice as private key and another as public key. This choice would be inconvenient as a basis needs $n^2$ elements to be represented. Such a large representation would not be practical, especially for the public key which needs to be transmitted to other parties.\\
On the other hand, the LWE shifts the focus of the problem to specific elements in the lattice which only need $n$ elements to be represented, while the lattice itself becomes a mere parameter of the problem.\\

\begin{definition}[Search LWE]
Let $\mathscr{L}$ be a lattice, $\mathbf{B}$ a basis for $\mathscr{L}$, $\chi[\mathbb{Z}_q^n]$ a Discrete Gaussian Distribution, and $\mathbf{s}\in\mathbb{Z}_q^n$. Given the noisy products $\mathbf{v}_i=\mathbf{Bs} + \mathbf{e}_i$, where $\mathbf{e}_i\xleftarrow{\$}\chi[\mathbb{Z}_q^n]$, find $\mathbf{s}$.
\end{definition}

\begin{remark}
The Discrete Gaussian Distribution is chosen to have width greater than $\sqrt{n}$.
\end{remark}

\begin{theorem}
LWE $\Leftrightarrow$ BDD
\end{theorem}
\begin{proof}
Let \it{A},\it{A'} algorithms to solve, respectively LWE and BDD.
\begin{itemize}
\item LWE $\geq$ BDD. Given an instance of BDD, with bound $\alpha$, $(\mathbf{B},\mathbf{z}+\mathbf{e})$, apply \it{A} to find $\mathbf{s}$, then $\mathbf{Bs}$ $\mathrm{mod}$ $q$ $=$ $\mathbf{z}$ or $\norm{\mathbf{e}}>\alpha$.
\item BDD $\geq$ LWE. Given an instance of LWE, $(\mathbf{B},\mathbf{Bs}+e)$, apply \it{A'} to find $B\mathbf{s}$, then multiply on the left by $\mathbf{B}^{-1}$ to find $\mathbf{s}$.
\end{itemize}
\end{proof}

\begin{definition}[Decision LWE]
Let $\mathscr{L}$ be a lattice, $\mathbf{B}$ a basis for $\mathscr{L}$, $\chi[\mathbb{Z}_q^n]$ a Discrete Gaussian Distribution, and $\mathbf{s}\in\mathbb{Z}_q^n$. Given two pairs $(\mathbf{B}, \mathbf{Bs}+\mathbf{e})$ and $(\mathbf{B},\mathbf{b})$, where $e\xleftarrow{\$}\chi[\mathbb{Z}_q^n]$ and $\mathbf{b}\xleftarrow{\$}U[\mathbb{Z}_q^n]$, distinguish the pair generated with the noisy product from the one sampled from the uniform distribution.
\end{definition}

\begin{theorem}
Search LWE and Decisional LWE are equivalent.
\end{theorem}
\begin{proof}
It is easy to see that any algorithm solving the Search LWE would naively solve the Decisional LWE, by searching for the solution, which only exists with negligible probability if $\mathbf{b}$ is uniformly random.\\
The converse is, as always, a bit tricky. The solution to this problem is to carefully craft the instances to feed into the decisional solver to guess $\mathbf{s}$ one component at a time.
Let us consider the first component.\\
First, a random $r\in\mathbb{Z}_q$ is sampled, and used to compute
\begin{equation*}
\mathbf{B}'=\mathbf{B}+
\begin{bmatrix}
r &&&\\
\vdots &  \multicolumn{2}{c}{\text{\large0}}\\
r &&& \\
\end{bmatrix},
\end{equation*}
then, the first component of $\mathbf{s}$ is guessed as $k\in\mathbb{Z}_q$. Finally, the guess is used to compute $\mathbf{b}'=\mathbf{b}+\left(\frac{rk}{q}\right)_{i=0}^{n-1}$. Feeding the instance $(\mathbf{B}',\mathbf{b}')$ in the decisional solver, it can be verified if $k$ is the correct guess for the first component of $\mathbf{s}$. This will be accomplished in at most $q$ attempts, and repeating the procedure for each component of $\mathbf{s}$, the complete vector can be recovered in at most $nq$ steps.
\end{proof}

\subsubsection{Drawbacks}
At the beginning of this section, it was mentioned how the LWE allows to shift the focus of the problem from the lattice itself, to its elements. Although this is a step in the right direction, a basis of the lattice is still required to carry out computations, which means that it must be somehow stored, leaving the elements required for the representation of the problem at $O(n^2)$. Even worse, if the parameters are not fixed\footnote{For instance to avoid all-for-the-price-of-one attacks} the lattice basis will have to be transmitted anyway, leaving the situation unchanged with respect to the first, simpler problems.\\
Luckily, there are some mitigations to these problems which still allow the creation practical primitives using the LWE problem. However, the very existence of these issues lead to the search of a new problem that did not have them to begin with. In the end, the most promising candidate was identified in the RLWE problem.

\subsection{The RLWE problem}
The RLWE problem is a specialized version of the LWE problem working on Ideal Lattices. Its purpose is to mitigate the shortcomings of the general LWE like the memory and bandwidth requirements. Considering the polynomial formulation of Ideal Lattices the Search RLWE can be defined as follows.

\begin{definition}[Serach RLWE]
Let $\mathscr{L}$ be the lattice in $\mathbb{Z}_q[x]/(f)$ defined by the polynomial $b$, $\chi[\mathbb{Z}_q[x]/(f)$ a Discrete Gaussian Distribution, and $\mathbf{s}\in\mathbb{Z}_q[x]/(f)$. Given the noisy products $\mathbf{v}_i=\mathbf{bs} + \mathbf{e}_i$, where $\mathbf{e}_i\xleftarrow{\$}\chi[\mathbb{Z}_q[x]/(f)]$, find $\mathbf{s}$.
\end{definition}

The decisional formulation of the RLWE problem can be defined as follows.

\begin{definition}[Decision RLWE]
\sloppy Let $\mathscr{L}$ be the lattice in $\mathbb{Z}_q[x]/(f)$ defined by the polynomial $\mathbf{b}$, $\chi[\mathbb{Z}_q[x]/(f)$ a Discrete Gaussian Distribution, and \mbox{$\mathbf{s}\in\mathbb{Z}_q[x]/(f)$}. Given two pairs $(\mathbf{b},\mathbf{bs} + \mathbf{e})$ and $(\mathbf{b},mathbf{w})$, where \mbox{$\mathbf{e}\xleftarrow{\$}\chi[\mathbb{Z}_q[x]/(f)]$}, and \mbox{$\mathbf{w}\xleftarrow{\$}U[\mathbb{Z}_q[x]/(f)]$}, distinguish the pair generated with the noisy product from the one sampled from the uniform distribution. 
\end{definition}

Because of the similarity with the LWE problem, the following theorems hold.

\begin{theorem}
RLWE $\Leftrightarrow$ BDD
\end{theorem}
\begin{theorem}
Search RLWE and Decisional RLWE are equivalent.
\end{theorem}

The proofs of these theorems can be carried out as they were in the context of Generic Lattices for LWE.\\

\subsubsection{Advantages of the RLWE}
The first advantage of the RLWE problem comes from the setting of Ideal Lattices. As mentioned above, this translates into a cheaper representation of the problem in terms of memory. Moreover, using the NTT the noisy products can be carried out in quasi linear time, compared to the quadratic time required by the noisy products in the LWE problem. Although the LWE primitives are already cheap from this point of view, this is still an advantage not to be underestimated.\\
Last but no least, the use of the polynomial product in $\mathbb{Z}[x]/(f)$ has huge repercussions in the applications. Indeed, when two vectors in $\mathbb{Z}_q^n$ are combined with the scalar product they produce just one scalar, but when two polynomial are multiplied together the result is a polynomial itself. The importance of this fact will be clearer when the applications will be presented. It suffices to say that if some information were to be extracted from the result of these products, the amount of information that could be retrieved in the setting of RLWE would be $n$ times the amount retrievable in the LWE setting.

\subsubsection{Security concerns}
The benefits of using the RLWE problem in building cryptosystems are undeniable. However, the introduction of additional structure in the lattices raised few security concerns. While some of the hard problems of lattices have been proven to be equally hard in Ideal Lattice as they are in the setting of Generic Lattices, this is not the case for the RLWE problem. Indeed, the hardness of the RLWE problem is still an open question. The lack of attacks against Ideal Lattices that fare better than their generic counterpart is reassuring, but without a formal proof of the equivalence of the two problems there is no guarantee this is going to always be the case.

\subsection{Hardness of the LWE problem}
In order to assess the hardness of the LWE problem, it is worth introducing two notions of hardness that a problem can satisfy.

\begin{definition}[Worst-Case and Average-Case Hardness]
A problem \textbf{P} is said to be worst-case hard if at least one instance of the problem is hard.
On the other hand, a problem \textbf{P'} is said to be average-case hard if the average instance of the problem is hard.
\end{definition}
\begin{remark}
It is quite evident that the average-case hardness of a problem is a stronger property that the worst-case hardness.
\end{remark}
In order for a problem to be suitable for the construction of cryptographic primitives it needs to be average-case hard. This requirement is stricter than one might think as many known hard problems are worst-case hard, but not average-case hard.\\
This is not the case for the LWE problem, which can be proven to be average-case hard both in a classical setting and in a quantum one. The foundation of this proof is the worst-case hardness of the SVP problem. This proposition has been proven in multiple ways using reductions from notorious hard problems such as the Subset Sum problem, or the Exact Set Cover, with early results dating back to 1998 \cite{svp_hardness}. With these results on the hardness of lattice based problems in place, the last piece of the puzzle to prove the average-case hardness of the LWE problem is a worst-to-average reduction from SVP to LWE, i.e. a reduction proving that an oracle solving an average instance of the LWE problem could be used to solve a worst-case instance of the SVP problem.\\
In fact, a worst-to-average quantum reduction for the LWE problem from the SVP was first constructed by Regev in \cite{lwe_q_hardness}, while a worst-to-average reduction from the same problem was constructed by Peikert in \cite{lwe_c_hardness}. These reductions prove that the LWE problem is average case hard, making it suitable as a basis for cryptosystems. This robust foundation, paired with the remarkable performance of the resulting primitives, makes the LWE problem one of the strongest candidates for building post quantum secure primitives.