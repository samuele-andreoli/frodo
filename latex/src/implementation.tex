%         Frodo

%         Parametri [https://bitbucket.org/malb/lwe-estimator]

%         Performance 

%                 Complessit√†
%                 Performace da soli
%                 Comparazione con altri metodi lattice based

\section{Computational Complexity}
The computational complexity of Frodo is dominated by the parameter generation, with a cost of $O(n^2)$, and the public key generation, with a cost of $O(\bar{m}n^2)$ or $O(\bar{n}n^2)$. Luckily, we tipically have $\bar{m},\bar{n} \ll n$, which means that the total cost of the algorithm cn be summed up as $O(n^2)$. This cost does not look promising, but these parameters are tipically very small, with $n$ being the highest, but still remaining abundantly lower that $1000$. Because of these small parameters, the actual cost of the protocol is remarkably small. Indeed, Frodo is just slightly slower than New Hope, and orders of magnitude faster than the competitor PQKE.\\
The real hit to the performance of Frodo comes from the memory usage and the bandwith. Again, the culprits are the parameter generation and the matrix multiplications.\\
As far as memory is concerned, the naive implemenation is still dominated by the memory necessary for the parameter $a$, which is $O(n^2)$, and the memor necessary for the private and public keys, which is $O(n)$\footnote{Considering, again, that $\bar{m},\bar{n} \ll n$}. In Section \ref{sec:fr:a_generation} there is an in-depth analysis of the cost, and the possible mitigations for the generation of the parameter $a$, which practically reduces the memory requirements to $O(n)$.\\
Bandwidth is another weak spot of Frodo, as the matrices that need to be transmitted are not small either. As seen above, these grow as $O(n)$, which translates in a pretty hefty amount of data to be exchanged.  


\section{Implementation Rationale}
As the main goal of this thesis is not to examine the differences of Frodo and New Hope only from a theoretical point of view, but also to give a practical comparison of the two, an original implementation is presented. It focuses on portability, low memory usage, both in terms of executable size and execution memory and It uses stack memory in all its internal functions, naturally avoiding issues related to memory handling, so frequent in a language like C.\\
The nature of the LWE primitives naturally suits a constant time implementation for the key generation and reconciliation primitives, and with a little more effort all the critical parts of the protocol can be made completely branchless, with only a few loops, which only depend on public parameters and not on execution data, neither private nor public.\\
With this in mind, the proposed implementation focuses on streamlining the one proposed by the authors of \cite{frodo}, pruning unnecessary branches and options that are a burden during execution and make the code less readable.\\
Let's examine in detail the different aspects of the protocol implementation.

\subsection{Element representation}
The core choice we need to make when implementing Frodo is element representation, which can either be tight or redundant. A tight representation would save memory, but it would burden the implementation with the modular arithmetic handling. On the other hand, a redundant representation would ease this burden, either by using lazy reduction, or by carefully selecting modulo and bits so that overflows can be exploited to automatically take care of modular arithmetic. This comes at the cost of an increased memory usage.\\
The authors of \cite{frodo} have no doubts on their choice, and their intents are quite clear from the parameters choice. They don't even consider using lazy reduction and force the modulus to be a power of two, thus enabling the implementation to ignore the modular arithmetic. Indeed, considering that the highest possible modulus in any parameter choice is $2^{15}$, an element of a matrix can always be represented as an integer in $\mathbb{Z}_{16}$. This means that an element can always fit an unsigned $16$ bit integer, regardless of the parameter choice, and that the modular arithmetic is taken car of by integer overflow.\\
The final advantage of this representation comes when an element needs to be reduced to fit in $\mathbb{Z}_n$: a single AND instruction with the mask $2^{n}-1$ is enough to compute the desired value. This final computation might not even be necessary, as it is often the case that either specific bits are extracted from the 16 bits integer itself, or that the integers are packed into byte arrays for transmission. In these cases, it is possible to perform the bitwise operations in such a way that the modular arithmetic is automatically handled.\\

\subsection{Parameter generation}
The parameter generation, alongside key pairs generation, is the most burdensome part of Frodo. Although, not much can be added to the considerations made in Section \ref{sec:fr:a_generation} about the generation of the parameter, either in full, or by row or column. It is only worth mentioning that while key generation needs to be handled with care to mitigate side channel attacks, the generation of the public parameter is not so critical. There is no advantage in loosening the requirements on constant timeness, but there are small gains from avoiding some of the final cleanups of the memory used in some parts of the procedure,. For instance, the buffers used in the AES encryption of the parameter stripes can be safely left alone.\\

\subsection{Matrix multiplication}\label{}
The shares recombination and the public key computation are nothing more than matrix multiplication, with the addition of the sampled noise matrices. Unfortunately, the dimension of the matrices used in Frodo is not high enough to justify more advanced methods of matrix multiplication, and the naive algorithm is the preferred choice. Still, the approach followed by the authors of Frodo for theses procedures can be improved. Let's examine how the original implementation behaves.\\
The tipical operation that needs to be executed when muliplying two matrices in Frodo, is not just a simple multiplication, but it also requires the addition of a sampled noise matrix, i.e. $ab + e$. In the original implementation, all the three matrices $a$, $b$, and $e$ are allocated, plus the destintion matrix. Then, the matrix e is copied into the destination matrix, and the product is computed and stored directly in the destination matrix.\\
It is easy to see that one of these allocations is unnecessary: the matrix $e$ is allocated, used to store the samples and then copied over to the destination. So, why not making the matrix $e$ itself the destination matrix. This approach saves the allocation of a matrix, which is quite burdensome, and also the time necessary to copy over the matrix e to the destination. Since the error matrices are generated on the fly and never reused, nothing is lost by destroying $e$, and it can save up to one third of the necessary memory, in the case of the multiplication with the parameter generated by rows. Even if the product does not require the addition of noise, there is no extra cost in zeroing the matrix before passing it to the multiplication utility, w.r.t zeroing out the matrix as we go during the product.\\

\subsection{Reconciliation}\label{sec:imp:reconciliation}
The implementation proposed by the authors of \cite{frodo} for the reconciliation follows the definition quite closely. First, the elements of the recombined share are crossrounded as described in Section \ref{sec:fr:reconciliation}, with or without the help of the hint, depending on which party is executing the reconciliation. Then, the desired bits are extracted from the matrices and packed into the agreed key, using generic packing utilities\footnote{More on these utilities in the next section}.\\
Tailoring the packing function to this use case, or even better performing the pakcing on the fly, could allow some tricks that would not be otherwise possible. Indeed, knowing in advance the position and number of bits to pack, 

\subsection{Element packing}
Although a redundant representation may be a good choice for internal element representation, it is not acceptable when the data has to be transmitted to the other party in the key exchange. This issue would add to the already hefty memory and bandwidth cost of Frodo. In order to address this problem, the elements in redundant representation are packed into the tight representation before transmission, and unpacked when received.\\
This part of the protocol is not really expensive, but there is much to improve in the original implementation. Indeed, the authors of \cite{frodo} try to fit the code for bit packing both to the element packing and the key packing from the reconciled combined shares. This overburdens the implementation with unnecessary complexity, forcing a packing algorithm that operates bit by bit, and ultimately resulting in fairly inefficient packing and unpacking procedures. Moreover, this choice might raise few eyebrows because it is used both for packing the public shares and the private reconciled secret. Decoupling the logic that handles private and public material allows for a simpler, branchless, implementation for the former, as seen in Section \ref{sec:imp:reconciliation}, and a more efficient implementation for the latter, scratching the requirements for constant timeness and memory safety.\\
To address this issue, this implementation proposes a bytewise packing procedure. Unfortunately, the parameter choice does not allow for the most efficient branchless implementation, except for the Frodo Classic parameters, but 